import { supabase } from './supabase'
import { Parent, Student, ParentStudent } from './types'
import { z } from 'zod'

const parentSchema = z.object({
  email: z.string().email('Invalid email address'),
  first_name: z.string().min(1, 'First name is required'),
  last_name: z.string().min(1, 'Last name is required'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
})

export type ParentFormData = z.infer<typeof parentSchema>

export interface FamilyData {
  parent: Parent & { user?: any }
  students: Student[]
}

export const familyService = {
  /**
   * Get all families with their students
   */
  async getAllFamilies(): Promise<{ data: FamilyData[] | null; error: any }> {
    try {
      const { data: parents, error: parentsError } = await supabase
        .from('parents')
        .select(`
          *,
          user:users(*),
          parent_students(
            student:students(*)
          )
        `)
        .order('user.created_at', { ascending: false })

      if (parentsError) {
        return { data: null, error: parentsError }
      }

      const families: FamilyData[] = (parents || []).map(parent => ({
        parent,
        students: parent.parent_students?.map((ps: any) => ps.student).filter(Boolean) || []
      }))

      return { data: families, error: null }
    } catch (error) {
      return { data: null, error }
    }
  },

  /**
   * Get family by parent ID
   */
  async getFamilyByParentId(parentId: string): Promise<{ data: FamilyData | null; error: any }> {
    try {
      const { data: parent, error: parentError } = await supabase
        .from('parents')
        .select(`
          *,
          user:users(*),
          parent_students(
            student:students(*)
          )
        `)
        .eq('user_id', parentId)
        .single()

      if (parentError) {
        return { data: null, error: parentError }
      }

      const family: FamilyData = {
        parent,
        students: parent.parent_students?.map((ps: any) => ps.student).filter(Boolean) || []
      }

      return { data: family, error: null }
    } catch (error) {
      return { data: null, error }
    }
  },

  /**
   * Create a new parent account and family
   */
  async createParent(parentData: ParentFormData): Promise<{ data: any | null; error: any }> {
    try {
      // Validate input
      parentSchema.parse(parentData)

      // Create auth user
      const { data: authData, error: authError } = await supabase.auth.signUp({
        email: parentData.email,
        password: parentData.password,
        options: {
          data: {
            first_name: parentData.first_name,
            last_name: parentData.last_name,
            role: 'parent'
          }
        }
      })

      if (authError) {
        return { data: null, error: authError }
      }

      if (!authData.user) {
        return { data: null, error: { message: 'Failed to create user account' } }
      }

      // The user record should be created automatically by the trigger
      // But we need to update the role to 'parent'
      const { error: updateError } = await supabase
        .from('users')
        .update({ role: 'parent' })
        .eq('id', authData.user.id)

      if (updateError) {
        console.error('Failed to update user role:', updateError)
      }

      // Create parent record (family_qr_code will be auto-generated by trigger)
      const { data: parentRecord, error: parentError } = await supabase
        .from('parents')
        .insert([{
          user_id: authData.user.id
        }])
        .select()
        .single()

      if (parentError) {
        return { data: null, error: parentError }
      }

      return { data: { user: authData.user, parent: parentRecord }, error: null }
    } catch (error) {
      if (error instanceof z.ZodError) {
        return { data: null, error: { message: error.errors[0].message } }
      }
      return { data: null, error }
    }
  },

  /**
   * Link student to parent
   */
  async linkStudentToParent(parentId: string, studentId: string): Promise<{ error: any }> {
    const { error } = await supabase
      .from('parent_students')
      .insert([{
        parent_id: parentId,
        student_id: studentId
      }])

    return { error }
  },

  /**
   * Unlink student from parent
   */
  async unlinkStudentFromParent(parentId: string, studentId: string): Promise<{ error: any }> {
    const { error } = await supabase
      .from('parent_students')
      .delete()
      .eq('parent_id', parentId)
      .eq('student_id', studentId)

    return { error }
  },

  /**
   * Get students not linked to any family
   */
  async getUnlinkedStudents(): Promise<{ data: Student[] | null; error: any }> {
    const { data, error } = await supabase
      .from('students')
      .select(`
        *,
        parent_students!left(parent_id)
      `)
      .is('parent_students.parent_id', null)
      .eq('status', 'Active')
      .order('first_name', { ascending: true })

    return { data, error }
  },

  /**
   * Get family by QR code
   */
  async getFamilyByQRCode(qrCode: string): Promise<{ data: FamilyData | null; error: any }> {
    try {
      const { data: parent, error: parentError } = await supabase
        .from('parents')
        .select(`
          *,
          user:users(*),
          parent_students(
            student:students(*)
          )
        `)
        .eq('family_qr_code', qrCode)
        .single()

      if (parentError) {
        return { data: null, error: parentError }
      }

      const family: FamilyData = {
        parent,
        students: parent.parent_students?.map((ps: any) => ps.student).filter(Boolean) || []
      }

      return { data: family, error: null }
    } catch (error) {
      return { data: null, error }
    }
  },

  /**
   * Delete parent and family (this will cascade delete parent_students records)
   */
  async deleteParent(parentId: string): Promise<{ error: any }> {
    try {
      // First delete the user account (this will cascade to parent and parent_students)
      const { error: userError } = await supabase.auth.admin.deleteUser(parentId)
      
      if (userError) {
        return { error: userError }
      }

      return { error: null }
    } catch (error) {
      return { error }
    }
  },

  /**
   * Update parent information
   */
  async updateParent(
    parentId: string, 
    updates: { first_name?: string; last_name?: string; email?: string }
  ): Promise<{ error: any }> {
    const { error } = await supabase
      .from('users')
      .update(updates)
      .eq('id', parentId)

    return { error }
  },

  /**
   * Generate family QR code data URL
   */
  async getFamilyQRCode(familyQRCode: string, familyName?: string): Promise<string | null> {
    try {
      const { qrCodeService } = await import('./qr-codes')
      return await qrCodeService.generateFamilyQR(familyQRCode, familyName)
    } catch (error) {
      console.error('Failed to generate family QR code:', error)
      return null
    }
  },

  validate: (data: any) => {
    try {
      return { data: parentSchema.parse(data), error: null }
    } catch (error) {
      return { data: null, error }
    }
  }
}